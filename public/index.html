<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Chess App — Setup → Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="chessboard-1.0.0.css" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; }
    .screen { display:none; }
    .screen.active { display:block; }
    form label { display:block; margin: 12px 0 4px; font-weight:600; }
    .row { display:flex; flex-wrap:wrap; gap:16px; align-items:center; }
    .row > * { flex: 1 1 220px; }
    #myBoard { width: 420px; max-width: 95vw; }
    .panel { display:grid; grid-template-columns: 1fr 1fr; gap: 16px; align-items:start; }
    .stat { margin-top: 8px; font-size: 14px; }
    .btn { padding:8px 12px; border:1px solid #ccc; border-radius:8px; background:#f7f7f7; cursor:pointer; }
    .btn.primary { background:#efefef; font-weight:600; }
    .clocks { display:flex; gap:16px; margin: 12px 0; }
    .clock { padding:8px 12px; border-radius:8px; background:#f5f5f5; min-width: 120px; text-align:center; }
    .clock.active { outline: 2px solid #444; }
    .muted { color:#666; font-size:12px; }
    #minutes {width: 150px; font-size: 12px; padding: 6px;}
    #increment {width: 150px; font-size: 12px; padding: 6px;}
    #opponent {width: 150px; font-size: 12px; padding: 6px;}
    #pColor {width: 150px; font-size: 12px; padding: 6px;}
  </style>
</head>
<body>
  <!-- SETUP SCREEN -->
  <section id="setup" class="screen active">
    <h2>New Game</h2>
    <form id="setupForm">
      <div class="row">
        <div>
          <label for="opponent">Opponent</label>
          <select id="opponent" name="opponent">
            <option value="human">Human (same device)</option>
            <option value="random">Computer (random legal moves)</option>
          </select>
        </div>
        <div>
          <label for="pColor">Play as</label>
          <select id="pColor" name="opponent">
            <option value="white">White</option>
            <option value="black">Black</option>
            <option value="random">Random</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="minutes">Time (minutes per side)</label>
          <input id="minutes" name="minutes" type="number" step="1" value="1" min="1" max="3" size="20" />
        </div>
        <div>
          <label for="increment">Increment (sec)</label>
          <input id="increment" name="increment" type="number" step="1" value="0" min="0" max="5" />
        </div>
      </div>

      <label for="fen">Start from FEN (optional)</label>
      <input id="fen" name="fen" type="text" placeholder="Leave blank for standard start" style="width:100%" />
      <div class="muted">Example: rnbqkbnr/ppp2ppp/8/3pp3/3P4/5N2/PPP1PPPP/RNBQKB1R w KQkq - 1 3</div>

      <div style="margin-top:16px">
        <button class="btn primary" type="submit">Start Game</button>
      </div>
    </form>
  </section>

  <!-- GAME SCREEN -->
  <section id="game" class="screen">
    <div class="panel">
      <div>
        <div id="myBoard"></div>
        <div class="clocks">
          <div id="whiteClock" class="clock">White: <span id="whiteTime">05:00</span></div>
          <div id="blackClock" class="clock">Black: <span id="blackTime">05:00</span></div>
        </div>
        <div class="row">
          <button id="undoBtn" class="btn">Undo</button>
          <button id="newBtn"  class="btn">New Game</button>
          <button id="resignBtn" class="btn">Resign</button>
        </div>
      </div>
      <div>
        <h3>Status</h3>
        <div id="status"></div>
        <div class="stat">FEN: <span id="fenOut" class="muted"></span></div>
        <div class="stat">PGN: <span id="pgnOut" class="muted"></span></div>
      </div>
    </div>
  </section>

  <!-- Dependencies (use your local copies as you already have) -->
  <script src="jquery.js"></script>
  <script src="chess.js"></script>
  <script src="chessboard-1.0.0.js"></script>

  <script>
    // --- State ---
    let game, board, settings, timer;
    let whiteMs = 0, blackMs = 0, incMs = 0;
    let ticking = false, lastTickAt = null, resultShown = false;

    function byId(id){ return document.getElementById(id); }
    function pad(n){ return n.toString().padStart(2,'0'); }
    function msToClock(ms){ if(ms < 0) ms = 0; const s = Math.floor(ms/1000); const m = Math.floor(s/60); const r = s%60; return `${pad(m)}:${pad(r)}`; }
    function setActiveClock(turn){
      byId('whiteClock').classList.toggle('active', turn === 'w');
      byId('blackClock').classList.toggle('active', turn === 'b');
    }

    function startClocks(){
      if (ticking) return;
      ticking = true; lastTickAt = performance.now();
      timer = setInterval(()=>{
        if (game.isGameOver() || resultShown) return;
        const now = performance.now();
        const dt = Math.floor(now - lastTickAt);
        lastTickAt = now;
        if (game.turn() === 'w') whiteMs -= dt; else blackMs -= dt;
        byId('whiteTime').textContent = msToClock(whiteMs);
        byId('blackTime').textContent = msToClock(blackMs);
        if (whiteMs <= 0 || blackMs <= 0) endOnTime();
      }, 200);
    }

    function stopClocks(){ if (timer){ clearInterval(timer); timer = null; } ticking = false; }

    function applyIncrementJustMoved(color){ if (incMs > 0){ if (color === 'w') whiteMs += incMs; else blackMs += incMs; updateClockUI(); } }
    function updateClockUI(){ byId('whiteTime').textContent = msToClock(whiteMs); byId('blackTime').textContent = msToClock(blackMs); }

    function endOnTime(){
      stopClocks();
      const winner = whiteMs <= 0 ? 'Black' : 'White';
      byId('status').textContent = `Time out. ${winner} wins.`;
      resultShown = true;
    }

    function updateStatus(){
      let status = '';
      let moveColor = game.turn() === 'w' ? 'White' : 'Black';
      setActiveClock(game.turn());
      if (game.isCheckmate()) {
        status = 'Game over, ' + (moveColor === 'White' ? 'Black' : 'White') + ' is victorious (checkmate).';
        stopClocks();
      } else if (game.isStalemate()) {
        status = 'Game drawn (' + (game.insufficient_material ? 'insufficient material' : game.in_stalemate ? 'stalemate' : '50-move or repetition') + ').';
        stopClocks();
      } else {
        status = moveColor + ' to move' + (game.inCheck ? ' — check!' : '');
      }
      byId('status').textContent = status;
      byId('fenOut').textContent = game.fen();
      byId('pgnOut').textContent = game.pgn();
    }

    function startGameFromSettings(cfg){
      // 1) Prepare state
      settings = cfg;
      const startFEN = (cfg.fen && cfg.fen.trim()) ? cfg.fen.trim() : undefined;
      game = new Chess(startFEN);

      // 2) Clocks
      whiteMs = cfg.minutes * 60 * 1000; blackMs = cfg.minutes * 60 * 1000; incMs = cfg.increment * 1000;
      updateClockUI();

      // 3) Board
      const orientation = cfg.playAs;
      board = Chessboard('myBoard', {
        position: game.fen(),
        orientation,
        draggable: true,
        pieceTheme: '../pieces/{piece}.png',
        // ↓ Anti-flicker: disable animations
        moveSpeed: 0,
        snapSpeed: 0,
        snapbackSpeed: 0,
        appearSpeed: 0,
        onDragStart: (source, piece, position, orientation)=>{
          if (game.isGameOver()) return false;
          const turn = game.turn() === 'w' ? 'w' : 'b';
          if ((turn === 'w' && piece.startsWith('b')) || (turn === 'b' && piece.startsWith('w'))) return false;
          if (cfg.opponent !== 'human'){
            const humanColor = cfg.playAs === 'white' ? 'w' : 'b';
            if (game.turn() !== humanColor) return false;
          }
        },
        onDrop: (source, target)=>{
          let move;
          try {
            move = game.move({ from: source, to: target, promotion: 'q' });
          } catch (err) {
            return 'snapback';
          }
          if (!move) return 'snapback';
          applyIncrementJustMoved(move.color);
          if (!ticking) startClocks();
          // Defer visual update to onSnapEnd to avoid double render
          maybeEngineMove();
        },
        onSnapEnd: ()=>{
          // Single, non-animated sync with game state
          board.position(game.fen(), false);
          updateStatus();
        }
      });

      // 4) If human chose Black, let White (engine or human2) move first
      updateStatus();
      showScreen('game');
      setActiveClock(game.turn());
      startClocks();
      maybeEngineMove();
    }

    function maybeEngineMove(){
      if (settings.opponent === 'human') return;
      const humanColor = settings.playAs === 'white' ? 'w' : 'b';
      if (game.isGameOver()) return;
      if (game.turn() === humanColor) return;
      setTimeout(()=>{
        const moves = game.moves();
        if (moves.length === 0) { updateStatus(); return; }
        const pick = moves[Math.floor(Math.random()*moves.length)];
        const move = game.move(pick);
        applyIncrementJustMoved(move.color);
        // ↓ Non-animated board sync (prevents flicker)
        board.position(game.fen(), false);
        updateStatus();
      }, 250);
    }

    function showScreen(id){
      document.querySelectorAll('.screen').forEach(el=> el.classList.remove('active'));
      byId(id).classList.add('active');
    }

    // --- Wire up Setup form ---
    byId('setupForm').addEventListener('submit', (e)=>{
      e.preventDefault();
      const form = e.currentTarget;
      const opponent = byId('opponent').value; // human | random
      let playAs = (new FormData(form)).get('color'); // white | black | random
      if (playAs === 'random') playAs = Math.random() < 0.5 ? 'white' : 'black';
      const minutes = Math.max(0, parseInt(byId('minutes').value || '0', 10));
      const increment = Math.max(0, parseInt(byId('increment').value || '0', 10));
      const fen = byId('fen').value;
      startGameFromSettings({ opponent, playAs, minutes, increment, fen });
    });

    // --- Buttons in game screen ---
    byId('undoBtn').addEventListener('click', ()=>{
      if (game.history().length === 0) return;
      game.undo();
      if (settings.opponent !== 'human' && game.turn() === (settings.playAs === 'white' ? 'b' : 'w')){
        game.undo();
      }
      // ↓ Non-animated board sync
      board.position(game.fen(), false);
      updateStatus();
    });

    byId('newBtn').addEventListener('click', ()=>{
      stopClocks();
      resultShown = false;
      showScreen('setup');
    });

    byId('resignBtn').addEventListener('click', ()=>{
      stopClocks();
      const winner = game.turn() === 'w' ? 'Black' : 'White';
      byId('status').textContent = `Resignation. ${winner} wins.`;
      resultShown = true;
    });
  </script>
</body>
</html>
